# The power of functional programming

Over the course of the last few parts, we've learned how to do for loops, Python-like generators, and imperative algorithms. What has that got to do with functional programming?

Someone once said: _Functional programming makes difficult tasks easy and easy tasks difficult._

What they meant was that while it's often easy to express a complex algorithm in a few (or even one) lines of code, common things, like making a simple interacting command line program can be challenging and not elegant at all.

I believe this is because some problems are just easier to express imperatively. I thus hope that by making imperative idioms easily expressible in Funky, we can have a language where difficult tasks are easy and easy tasks are easy alike. Really difficult tasks will remain difficult, I'm sorry.

So, how does Funky support the _proper_ functional programming idioms? In this part, we'll focus on lists, the powerhouse of functional programming, and take a look at some really cool programs.
