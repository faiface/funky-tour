<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Isn't := imperative? - A Tour of Funky</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="1-taking-off-the-ground.html"><strong aria-hidden="true">1.</strong> Taking off the ground</a></li><li><ol class="section"><li><a href="1-1-installing.html"><strong aria-hidden="true">1.1.</strong> Installing</a></li><li><a href="1-2-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, world!</a></li><li><a href="1-3-expressions-and-types.html"><strong aria-hidden="true">1.3.</strong> Expressions and types</a></li><li><a href="1-4-semicolons-and-lambdas.html"><strong aria-hidden="true">1.4.</strong> Semicolons and lambdas</a></li><li><a href="1-5-a-bit-more-about-io.html"><strong aria-hidden="true">1.5.</strong> A bit more about IO</a></li><li><a href="1-6-putting-it-together-a-calculator.html"><strong aria-hidden="true">1.6.</strong> Putting it together: a calculator</a></li></ol></li><li><a href="2-making-the-world-our-own.html"><strong aria-hidden="true">2.</strong> Making the world our own</a></li><li><ol class="section"><li><a href="2-1-functions.html"><strong aria-hidden="true">2.1.</strong> Functions</a></li><li><a href="2-2-records.html"><strong aria-hidden="true">2.2.</strong> Records</a></li><li><a href="2-3-unions.html"><strong aria-hidden="true">2.3.</strong> Unions</a></li><li><a href="2-4-aliases.html"><strong aria-hidden="true">2.4.</strong> Aliases</a></li></ol></li><li><a href="3-the-other-half-of-the-language.html"><strong aria-hidden="true">3.</strong> The other half of the language</a></li><li><ol class="section"><li><a href="3-1-for-loop-is-a-function.html"><strong aria-hidden="true">3.1.</strong> For loop is a function</a></li><li><a href="3-2-yield-it-all.html"><strong aria-hidden="true">3.2.</strong> Yield it all!</a></li><li><a href="3-3-isn't-colon-equals-imperative.html" class="active"><strong aria-hidden="true">3.3.</strong> Isn't := imperative?</a></li><li><a href="3-4-maybe-some-pairs.html"><strong aria-hidden="true">3.4.</strong> Maybe some pairs</a></li><li><a href="3-5-appendix-a-list-of-useful-functions.html"><strong aria-hidden="true">3.5.</strong> Appendix: a list of useful functions</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">A Tour of Funky</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#isnt--imperative" id="isnt--imperative"><h1>Isn't := imperative?</h1></a>
<p>Sometimes, the best way to express a function is by a series of state-changing steps. In other words, by an <em>imperative algorithm</em>. For example, say we want to reverse a list. That's a fairly common thing. Sure, we could use the <code>reverse</code> function from the standard library, but how can we make one ourselves?</p>
<p>Here's a way to make it happen:</p>
<ol>
<li>Have two variables: <code>left</code> and <code>right</code>.</li>
<li>Store the input list in the <code>left</code> variable.</li>
<li>Store an empty list in the <code>right</code> variable.</li>
<li>Repeat until the <code>left</code> list is empty:
<ol>
<li>Add the first element of the <code>left</code> list to the beginning of the <code>right</code> list.</li>
<li>Remove the first element from the <code>left</code> list.</li>
</ol>
</li>
<li>Output the <code>right</code> list.</li>
</ol>
<p>For example, let's try and reverse <code>[1, 2, 3, 4, 5]</code>. Here's how the algorithm would proceed:</p>
<pre><code>           left | right
[1, 2, 3, 4, 5] | []
   [2, 3, 4, 5] | [1]
      [3, 4, 5] | [2, 1]
         [4, 5] | [3, 2, 1]
            [5] | [4, 3, 2, 1]
             [] | [5, 4, 3, 2, 1]
</code></pre>
<p>At the end, the <code>left</code> list is empty and the <code>right</code> list contains the reversed version of the original input list.</p>
<blockquote>
<p><strong>Note.</strong> Adding/removing an element to/from the beginning of a list is efficient (<a href="https://en.wikipedia.org/wiki/Time_complexity#Constant_time">constant time</a>). The whole algorithm therefore runs in time <a href="https://en.wikipedia.org/wiki/Time_complexity#Linear_time">linearly proportional</a> to the size of the list.</p>
</blockquote>
<p>How could we implement such an algorithm in Funky?</p>
<p>Well, this one isn't particularly hard. We can utilize recursion to simulate the state flow. We create a function called <code>my-reverse-algo</code>, which has two arguments: <code>left</code> and <code>right</code>. Those represent the two variables used in the algorithm. If the <code>left</code> list is empty, <code>my-reverse-algo</code> simply returns the <code>right</code> list. Otherwise, it returns from a recursive call with the variables updated appropriately.</p>
<pre><code class="language-funky">func my-reverse-algo : List a -&gt; List a -&gt; List a =
    \left \right
    if (empty? left) right;
    my-reverse-algo (rest! left) (first! left :: right)
</code></pre>
<blockquote>
<p><strong>Details.</strong> In most languages, each recursive call would grow the stack and we would quickly run out of memory. This doesn't happen in Funky thanks to <a href="https://en.wikipedia.org/wiki/Tail_call">tail recursion</a>. If a function should evaluate directly to another function call, it simply jumps to that function, effectively creating an efficient loop.</p>
</blockquote>
<p>Now we'll use <code>my-reverse-algo</code> to implement <code>my-reverse</code>. It'll just pass the correct initial values to <code>my-reverse-algo</code>:</p>
<pre><code class="language-funky">func my-reverse : List a -&gt; List a =
    \list
    my-reverse-algo list []
</code></pre>
<p>Let's see if it works!</p>
<pre><code class="language-funky">func main : IO =
    for (my-reverse [1, 2, 3, 4, 5])
        (println . string);
    quit
</code></pre>
<p>And run it:</p>
<pre><code>$ funkycmd my-reverse.fn
5
4
3
2
1
</code></pre>
<p>Nice!</p>
<a class="header" href="#the-recur-function" id="the-recur-function"><h2>The <code>recur</code> function</h2></a>
<p>Could we somohow get rid of the helper <code>my-reverse-algo</code> function? It isn't really useful on its own, it's just an implementation detail. It shouldn't be there.</p>
<p>What would help would be some way to define recursive functions anonymously, i.e. without making a global <code>func</code> definition. That way we could define <code>my-reverse-algo</code> directly inside <code>my-reverse</code>.</p>
<p>The function for this job is called <code>recur</code>, otherwise known as the <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator"><em>fixpoint combinator</em></a>, or the <em>Y combinator</em>. It's a pretty mind-blowing function. I won't explain how it works (it took me a long time to figure it out), but I'll explain how you can use it.</p>
<p>Here's the type, but it won't help you figure out much:</p>
<pre><code>$ funkycmd -types
&gt; recur
(a -&gt; a) -&gt; a
</code></pre>
<p>Okay, so how to use it? Let's take this really simple recursive function:</p>
<pre><code class="language-funky">func ones : List Int = 1 :: ones  # [1, 1, 1, ...]
</code></pre>
<p>It isn't even a function, it's just a recursive list.</p>
<p>We can express the same recursive list using <code>recur</code> like this:</p>
<pre><code class="language-funky">recur \ones 1 :: ones
</code></pre>
<p>The variable <code>ones</code> isn't a global definition in this case, it's just a local bindning. Does it work?</p>
<pre><code class="language-funky">func main : IO =
    for (take 5; recur \ones 1 :: ones)
        (println . string);
    quit
</code></pre>
<p>We only take the first five elements, because the list is infinite.</p>
<pre><code>$ funkycmd ones.fn
1
1
1
1
1
</code></pre>
<p>It does work!</p>
<p>What about this function?</p>
<pre><code class="language-funky">func count-from : Int -&gt; List Int =
    \x x :: count-from (x + 1)
</code></pre>
<p>For example, <code>count-from 4</code> evaluates to <code>[4, 5, 6, 7, ...]</code>.</p>
<p>With <code>recur</code>, it looks like this:</p>
<pre><code class="language-funky">recur \count-from \x
x :: count-from (x + 1)
</code></pre>
<p>You can try it yourself. Remember, that this time it's a function with one argument, so you need to pass it in.</p>
<p>So, I guess you got it, right? <strong>To define an anonymous recursive function</strong>, simply type <code>recur</code> and pass it a lambda where the first argument acts as the name of the recursive function and the rest are its arguments. Simple as that.</p>
<a class="header" href="#the--function" id="the--function"><h3>The <code>|&gt;</code> function</h3></a>
<p>What about <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci</a>?</p>
<pre><code class="language-funky">recur \fibs \a \b
a :: fibs b (a + b)
</code></pre>
<p>This defines a function that given two initial numbers produces a Fibonacci-like sequence. If we give it 0 and 1 as the initial numbers, it will produce the Fibonacci sequence precisely:</p>
<pre><code class="language-funky">(recur \fibs \a \b
a :: fibs b (a + b)) 0 1
</code></pre>
<p>Have you noticed them? The 0 and 1 that we passed in. They are right there, at the end of the expression. Perhaps you saw them, perhaps you didn't, but you surely must admit that it doesn't look very fashionable.</p>
<p>Instead of simply passing the arguments as usual, we can use the <code>|&gt;</code> function to pass them. It works like this:</p>
<pre><code class="language-funky">x |&gt; f
</code></pre>
<p>is the same as:</p>
<pre><code class="language-funky">f x
</code></pre>
<p>So, with <code>|&gt;</code>, we can rewrite the previos expression like this, but we need to pass the arguments in a seemingly reverse order:</p>
<pre><code class="language-funky">1 |&gt; 0 |&gt; recur \fibs \a \b
a :: fibs b (a + b)
</code></pre>
<blockquote>
<p><strong>Explanation.</strong> The above code works, we pass <code>0</code> for <code>a</code> and <code>1</code> for <code>b</code>, not the other way around. This is because <code>y |&gt; x |&gt; f</code> is the same as <code>y |&gt; (x |&gt; f)</code>, which reduces to <code>y |&gt; f x</code>, and finally <code>f x y</code>.</p>
</blockquote>
<p>This whole expression evaluates to just <code>[0, 1, 1, 2, 3, 5, 8, 13, 21, ...]</code>, the infinite Fibonacci sequence.</p>
<p>I admit, the whole thing about passing the arguments in a seemingly reverse order may look kinda confusing to you, but don't worry, you'll get used it. It's very versatile, and the whole thing didn't require a single language addition.</p>
<a class="header" href="#back-to-reversing-lists" id="back-to-reversing-lists"><h3>Back to reversing lists</h3></a>
<p>Can we use <code>recur</code> to get rid of the extra <code>my-reverse-algo</code> function?</p>
<p>For the reminder, here's how it looks with the extra function:</p>
<pre><code class="language-funky">func my-reverse-algo : List a -&gt; List a -&gt; List a =
    \left \right
    if (empty? left) right;
    my-reverse-algo (rest! left) (first! left :: right)

func my-reverse : List a -&gt; List a =
    \list
    my-reverse-algo list []
</code></pre>
<p>And here's the solution. All we have to do is replace <code>my-reverse-algo</code> in the body of <code>my-reverse</code> with an anonymous definition:</p>
<pre><code class="language-funky">func my-reverse : List a -&gt; List a =
    \list
    (recur \my-reverse-algo \left \right
    if (empty? left) right;
    my-reverse-algo (rest! left) (first! left :: right)) list []
</code></pre>
<p>And we'll use <code>|&gt;</code> to make it more readable:</p>
<pre><code class="language-funky">func my-reverse : List a -&gt; List a =
    \list
    [] |&gt; list |&gt; recur \my-reverse-algo \left \right
    if (empty? left) right;
    my-reverse-algo (rest! left) (first! left :: right)
</code></pre>
<p><strong>The last change we'll make</strong> is we'll rename <code>my-reverse-algo</code> to simply <code>loop</code>:</p>
<pre><code class="language-funky">func my-reverse : List a -&gt; List a =
    \list
    [] |&gt; list |&gt; recur \loop \left \right
    if (empty? left) right;
    loop (rest! left) (first! left :: right)
</code></pre>
<p><strong>This is a little convention.</strong> In cases like this, we choose <code>loop</code> as the local name of the recursive function. It makes it immediately clear that we're using <code>recur</code> to simulate a simple stateful loop.</p>
<a class="header" href="#procedures" id="procedures"><h2>Procedures</h2></a>
<p>Sometimes, simple loops like the above aren't powerful enough. Of course, we prefer them whenever possible. But some algorithms require a more nuanced expression.</p>
<p>A good example is the <strong>imperative version of the <a href="https://en.wikipedia.org/wiki/Quicksort">quicksort algorithm</a></strong>, i.e. quicksort on random-access arrays. That's a little too tough for the start, but we'll come back to it by the end of this part.</p>
<p>First, we need to learn how to express imperative algorithms. The standard library offers a type specifically for this purpose: <code>Proc</code>. That's short for <em>procedure</em>. It's a simple union with this definition:</p>
<pre><code class="language-funky">union Proc s r =
    view (s -&gt; Proc s r)       |
    update (s -&gt; s) (Proc s r) |
    return r                   |
</code></pre>
<blockquote>
<p><strong>Note.</strong> <code>Proc</code> is an equivalent of the <a href="https://wiki.haskell.org/State_Monad"><code>State</code> monad</a> from Haskell and was initially called the same.</p>
</blockquote>
<p>So, what's <code>Proc</code> all about? You can think of it as a description of a procedure that runs in some stateful context, (usually) changes it, and results in some return value. Let's take a close look!</p>
<p>First, it has <strong>two type variables</strong>:</p>
<ul>
<li><strong><code>s</code></strong>. This is the type of the state context the procedure will run in. For example, if <code>s</code> is <code>Int</code>, then the procedure will begin its execution with some initial <code>Int</code>, say <code>4</code>, be able to change it and check its current value during its execution.</li>
<li><strong><code>r</code></strong>. This it the return type. When a procedure finishes, it returns some value, just like procedures in imperative languages.</li>
</ul>
<p>Second, it's a union with <strong>three alternatives or commands</strong>:</p>
<ul>
<li><strong><code>view</code></strong>. Used to check the current value of the state. Notice that its signature resembles the signature of <code>scanln</code> and similar functions. It's used the same way.</li>
<li><strong><code>update</code></strong>. This one is used to change the state. It takes a function of type <code>s -&gt; s</code>. When executing the procedure, the current state will be mapped through this function. The second argument is a contination - tells what should be done next. The <code>update</code> function is used in the same way as <code>println</code> and similar functions.</li>
<li><strong><code>return</code></strong>. Marks the end of the procedure and specifies the return value.</li>
</ul>
<p>Using these three instructions together with our already acquired battle-tested tools, like <code>if</code> and <code>for</code>, we can make descriptions of stateful procedures.</p>
<p>Let's see that in action!</p>
<p>Our first trivial example will be a procedure who's state context is just an <code>Int</code> and which returns an <code>Int</code> as well. When executed, it will increment the number in the state by 1 and return its new value.</p>
<pre><code class="language-funky">func increment : Proc Int Int =
    update (+ 1);
    view \x
    return x
</code></pre>
<p>First, we update the state using <code>(+ 1)</code> (which is the same as <code>(\x x + 1)</code>). Then we get the current (updated) state and return it.</p>
<p>The <strong><code>return</code> function has an overloaded version</strong>:</p>
<pre><code class="language-funky">func return : (s -&gt; r) -&gt; Proc s r =
    \f
    view \x
    return (f x)
</code></pre>
<p>It takes the current state and makes a return value from it using the supplied function. In our case, we just want to return the state directly, so we'll use <code>self</code> (which is the identity function: <code>\x x</code>):</p>
<pre><code class="language-funky">func increment : Proc Int Int =
    update (+ 1);
    return self
</code></pre>
<p>That's quite neat! Now, keep in mind, all we have constructed is a data structure - a description. How do we execute it?</p>
<p><strong>We need to provide some initial state value.</strong> The function <code>start-with</code> is for just that. Here's how it looks like:</p>
<pre><code class="language-funky">func start-with : s -&gt; Proc s r -&gt; r
</code></pre>
<p>It takes the initial state, then a procedure, and apparently it executes the procedure and evaluates to its return value. Let's see how that works!</p>
<pre><code class="language-funky">func main : IO =
    let (start-with 6 increment) \x
    println (string x);
    quit
</code></pre>
<p>And run this:</p>
<pre><code>$ funkycmd increment.fn
7
</code></pre>
<p>What if we want to execute <code>increment</code> multiple times? We can do that using the <code>call</code> function:</p>
<pre><code class="language-funky">func call : Proc s a -&gt; Proc s b -&gt; Proc s b
</code></pre>
<p>This function is used for <strong>executing one procedure inside another procedure</strong>, discarding the return value of the first (we are able to get it, just wait a moment).</p>
<p>It takes two procedures and produces a new procedure that executes them one after another, returning the result of the second one.</p>
<pre><code class="language-funky">func main : IO =
    let (start-with 6 (call increment increment)) \x
    println (string x);
    quit
</code></pre>
<p>Does it work?</p>
<pre><code>$ funkycmd call.fn
8
</code></pre>
<p>Yep, it works! We can even reorganize it horizontally:</p>
<pre><code class="language-funky">func main : IO =
    let (
        start-with 6;
        call increment;
        increment
    ) \x
    println (string x);
    quit
</code></pre>
<p>We could even increment four times!</p>
<pre><code class="language-funky">func main : IO =
    let (
        start-with 6;
        call increment;
        call increment;
        call increment;
        increment
    ) \x
    println (string x);
    quit
</code></pre>
<p>The <code>call</code> function has another version with this type:</p>
<pre><code class="language-funky">func call : Proc s a -&gt; (a -&gt; Proc s b) -&gt; Proc s b
</code></pre>
<p>It's the same as the first version, except that instead of taking just a procedure as the second argument, it accepts a function taking the return value of the first procedure. The usage is quite straightforward.</p>
<p>Just for fun, let's gather all the return values from those three <code>increment</code>s using this new <code>call</code> version and return their sum:</p>
<pre><code class="language-funky">func main : IO =
    let (
        start-with 6;
        call increment \x
        call increment \y
        call increment \z
        return (x + y + z)
    ) \w
    println (string w);
    quit
</code></pre>
<p>What will be the result?</p>
<pre><code>$ funkycmd call.fn
24
</code></pre>
<p>That's because 7+8+9=24.</p>
<a class="header" href="#records-as-state-contexts-----and-" id="records-as-state-contexts-----and-"><h3>Records as state contexts (<code>&lt;-</code>, <code>-&gt;</code>, and <code>:=</code>)</h3></a>
<p>Imperative algorithms usually work with <strong>multiple variables</strong>.</p>
<p>For example, a simple algorithm to accumulate an average of a stream of numbers must store two variables: the sum and the count. The final average is then obtained by dividing one by the other. To add a number to the average, we add it to the sum and we increase the count by 1.</p>
<p>A natural way to store these two variables in Funky is with a record:</p>
<pre><code class="language-funky">record Average =
    sum   : Int,
    count : Int,
</code></pre>
<p>Then, using the record accessors, we can make a procedure to add a number to the average:</p>
<pre><code class="language-funky">func add : Int -&gt; Proc Average Nothing =
    \number
    update (sum (+ number));
    update (count (+ 1));
    return nothing
</code></pre>
<p>We use the <code>Nothing</code> return type, which is a type with only a single possible value: <code>nothing</code>. We use it to denote a procedure with no (useful) return value.</p>
<blockquote>
<p><strong>Note.</strong> <code>Nothing</code> is the same type as <code>()</code> in Haskell or <code>Unit</code> in some other languages.</p>
</blockquote>
<p>This isn't so bad. But, trust me, writing <code>update (field ...)</code> over and over gets tiresome with longer procedures. Records are so frequent here that the standard library provides some special treatment for them.</p>
<p><strong>The first function for this purpose is <code>&lt;-</code>.</strong> It's used to change a record field (or a nested field) in a procedure. Whenever you write this:</p>
<pre><code class="language-funky">update (field function)
</code></pre>
<p>you can instead rewrite it to this:</p>
<pre><code class="language-funky">field &lt;- function
</code></pre>
<blockquote>
<p><strong>Note.</strong> The <code>&lt;-</code> function has type <code>((a -&gt; a) -&gt; s -&gt; s) -&gt; (a -&gt; a) -&gt; Proc s r -&gt; Proc s r</code>.</p>
</blockquote>
<p>Therefore, we can rewrite our <code>add</code> function into this beautiful piece of code:</p>
<pre><code class="language-funky">func add : Int -&gt; Proc Average Nothing =
    \number
    sum &lt;- + number;
    count &lt;- + 1;
    return nothing
</code></pre>
<p>Pretty cool, don't you think?</p>
<p><strong>Another useful function is <code>-&gt;</code>.</strong> On the left side, it takes a getter, a function from the state type. Then it passes its result to the lambda on the right. It's like an enhanced <code>view</code> - whereas <code>view</code> always gives back the entire state, <code>-&gt;</code> gives you the part of the state you request.</p>
<p>For example, how about a procedure that returns the actual current average as an <code>Int</code>?</p>
<pre><code class="language-funky">func average : Proc Average Int =
    sum -&gt; \s
    count -&gt; \c
    return (if (zero? c) 0 (s / c))
</code></pre>
<p>Simple as that. We make sure to handle the case when the <code>count</code> is 0 using <code>if</code> as a ternary operator.</p>
<p>Using <code>add</code> and <code>average</code>, we can compose an imperative algorithm for calculating the average of a list:</p>
<pre><code class="language-funky">func average : List Int -&gt; Int =
    \numbers
    start-with (Average 0 0);
    for numbers (call . add);
    call average \avg  # call to the procedure, not a recursive call
    return avg
</code></pre>
<blockquote>
<p><strong>Note.</strong> We overloaded the name <code>average</code> for two purposes here: one is the procedure and the other is the function. No worries, Funky can always tell the difference.</p>
</blockquote>
<p>Notice that this <code>average</code> function has no <code>Proc</code> in the type. All the procedure stuff is encapsulated inside of it. To the outside world, it appears simply as another function.</p>
<p><strong>The last function for working with records in procedures is <code>:=</code>.</strong> It's similar to <code>&lt;-</code>, but instead of transforming the original value using a function, it simply overwrites it with a new value.</p>
<p>In other words, you can always replace this:</p>
<pre><code class="language-funky">field &lt;- const value
</code></pre>
<p>with this:</p>
<pre><code class="language-funky">field := value
</code></pre>
<p>Say we wanted to reset the average counter. Here's what it would look like:</p>
<pre><code class="language-funky">func reset : Proc Average Nothing =
    sum := 0;
    count := 0;
    return nothing
</code></pre>
<blockquote>
<p><strong>Details.</strong> There's an overloaded version of <code>:=</code> which takes a function from the state instead of a direct value. It can be used to copy one part of the state into another. We could for example write: <code>sum := count</code>, even though that wouldn't make any sense. But, be careful. You <strong>can't</strong> write <code>sum := count * 2</code>, because <code>count</code> is a getter (a function) here, not a number. You could write <code>sum := (\s count s * 2)</code>, though.</p>
</blockquote>
<p>By the way, <strong>the function <code>self</code></strong> acts as both a getter and an updater for the whole state. Remember this function?</p>
<pre><code class="language-funky">func increment : Proc Int Int =
    update (+ 1);
    return self
</code></pre>
<p>We can rewrite it:</p>
<pre><code class="language-funky">func increment : Proc Int Int =
    self &lt;- + 1;
    return self
</code></pre>
<p>Yes, this usage was one of the motivations for naming it <code>self</code> instead of <code>id</code>.</p>
<a class="header" href="#arrays" id="arrays"><h3>Arrays</h3></a>
<p>The last piece of puzzle before we can finally implement the quicksort algorithm is random-access arrays.</p>
<p>Arrays in Funky are a bit different than arrays in imperative language, because we aren't allowed to mutate anything. To change an element in an array we must make a new array. But no full copies need to be performed. The new array can always share as much data as possible with the old one and thus the whole operation will be quite cheap.</p>
<blockquote>
<p><strong>Details.</strong> Without cheating, there's really no such thing as in-place, mutable, <a href="https://en.wikipedia.org/wiki/Time_complexity#Constant_time">O(1)</a> access arrays in pure functional programming. All data structures have to be primarily tree-based and persistent.</p>
<p>However, there are efficient ways of implementing persistant arrays with O(log n) access time.</p>
</blockquote>
<p>Currently, the <code>Array</code> type in Funky implements an infinite array indexed by <code>Int</code>s (both positive and negative). <strong>To create an empty array, we use the <code>empty</code> function</strong>:</p>
<pre><code class="language-funky">func empty : a -&gt; Array a
</code></pre>
<p>It takes one argument, which is the default initial value for all elements. For example:</p>
<pre><code class="language-funky">empty 0
</code></pre>
<p>is an <code>Array Int</code> full of zeros. <strong>We use <code>at</code> to both get and update any element</strong> in the array. Here are the two overloaded versions:</p>
<pre><code class="language-funky">func at : Int -&gt; Array a -&gt; a
func at : Int -&gt; (a -&gt; a) -&gt; Array a -&gt; Array a
</code></pre>
<p>As you have surely noticed, they look very similar to getters and updaters in records, except that they take an additional <code>Int</code> argument - the index. For example:</p>
<pre><code class="language-funky">at 5 array
</code></pre>
<p><strong>gets the element at the index 5</strong>, while:</p>
<pre><code class="language-funky">at 5 (+ 3) array
</code></pre>
<p>evaluates to a <strong>new array, where that element is increased by 3</strong>.</p>
<p>There are two more functions, namely <code>reset</code> and <code>swap</code>. We won't cover the first one, but we'll come back to the second one when we get to the quicksort.</p>
<p>That's basically all there is to arrays. <strong>The interesting part comes when integrating them with procedures.</strong></p>
<p>As we've already noticed, both version of <code>at</code> fit very well with the form of record accessors. And we can, in fact, use them the same way in procedures. For example:</p>
<pre><code class="language-funky">func some-array : Array Int =
    start-with (empty 0);
    at 0 := 7;
    at 1 := 4;
    at 2 := 9;
    at 3 := 5;
    at 4 := 2;
    return self

func main : IO =
    for (range 0 4) (
        \i \next
        println (string; at i some-array);
        next
    );
    quit
</code></pre>
<p>We manually assign values to the elements of an array. Then, in <code>main</code>, we loop over the indices from 0 to 4 and print the corresponding elements from the array. Does it work?</p>
<pre><code>$ funkycmd array.fn
7
4
9
5
2
</code></pre>
<p>Sure enough it does!</p>
<p>We can even shorten <code>some-array</code> with a for loop:</p>
<pre><code class="language-funky">func some-array : Array Int =
    start-with (empty 0);
    for-pair (enumerate [7, 4, 9, 5, 2])
        (\i \x at i := x);
    return self
</code></pre>
<p>Now that we know arrays, let's get on to the quicksort!</p>
<a class="header" href="#quicksort" id="quicksort"><h3>Quicksort</h3></a>
<p>If you've ever implemented quicksort, you must know that it's quite tricky to get it right unless you're a super brilliant genius. At least the first time.</p>
<p>Because of that, we'll make our job easier and <strong>simply translate <a href="https://en.wikipedia.org/wiki/Quicksort#Algorithm">this algorithm from Wikipedia</a></strong>:</p>
<pre><code>algorithm quicksort(A, lo, hi) is
    if lo &lt; hi then
        p := partition(A, lo, hi)
        quicksort(A, lo, p - 1)
        quicksort(A, p + 1, hi)

algorithm partition(A, lo, hi) is
    pivot := A[hi]
    i := lo
    for j := lo to hi - 1 do
        if A[j] &lt; pivot then
            swap A[i] with A[j]
            i := i + 1
    swap A[i] with A[hi]
    return i
</code></pre>
<p>That's a pseudocode. We'll try and translate it to Funky. We'll make two procedures: <code>quicksort</code> and <code>partition</code>.</p>
<p>Since these are imperative, we'll need the array in their mutable state. The <code>partition</code> procedure also uses an index <code>i</code>, so we'll also need that in the state. This will be our state:</p>
<pre><code class="language-funky">record Vars =
    array : Array Int,
    i     : Int,
</code></pre>
<blockquote>
<p><strong>Note.</strong> The <code>partition</code> procedure also uses an index <code>j</code>, but we need not include it in the state.</p>
</blockquote>
<p>Okay, now let's try and translate <code>partition</code>. I won't do it step-by-step, this is more of a show-off than a tutorial, but I'm sure you'll be able to follow it. Here it is:</p>
<pre><code class="language-funky">func partition : Int -&gt; Int -&gt; Proc Vars Int =
    \lo \hi
    (at hi . array) -&gt; \pivot
    i := lo;
    for (range lo (hi - 1)) (
        \j \next
        (at j . array) -&gt; \at-j
        when (at-j &lt; pivot) (
            \next
            i -&gt; \ii
            array &lt;- swap ii j;
            i &lt;- + 1;
            next
        );
        next
    );
    i -&gt; \ii
    array &lt;- swap ii hi;
    return ii
</code></pre>
<blockquote>
<p><strong>Details.</strong> The <code>swap</code> function has type <code>Int -&gt; Int -&gt; Array a -&gt; Array a</code> and does the obvious: evaluates to an array with the corresponding elements swapped.</p>
</blockquote>
<p>It's definitely a little longer than the pseudocode. Most of the extra lines are from the lambdas and getting the current value of <code>i</code>. But otherwise, it reads very similar.</p>
<p>Now onto the <code>quicksort</code> procedure:</p>
<pre><code class="language-funky">func quicksort : Int -&gt; Int -&gt; Proc Vars Nothing =
    \lo \hi
    if (lo &gt;= hi)
        (return nothing);
    call (partition lo hi) \p
    call (quicksort lo (p - 1));
    call (quicksort (p + 1) hi);
    return nothing
</code></pre>
<p>This one is very straightforward. The only thing we changed from the pseudocode is that we inverted the condition. The pseudocode <em>does</em> something when <code>lo &lt; hi</code>, we instead <em>halt</em> the procedure in the other case.</p>
<p>Let's see if this all works.</p>
<pre><code class="language-funky">func main : IO =
    let (
        start-with (Vars (empty 0) 0);
        for-pair (enumerate [2, 6, 1, 0, 4, 3, 5, 9, 7, 8])
            (\i \x (array . at i) := x);
        call (quicksort 0 9);
        return array
    ) \arr
    for (range 0 9) (
        \i \next
        println (string; at i arr);
        next
    );
    quit
</code></pre>
<p>In this <code>main</code> function, we first start with an empty array and a zero <code>i</code> variable (which is irrelevant). Then we assign some random numbers to the first 10 indices of the array. Then we quicksort them and bind the resulting array to <code>arr</code> using <code>let</code>. Then we print the first 10 elements and see if it worked:</p>
<pre><code class="language-funky">$ funkycmd quicksort.fn
0
1
2
3
4
5
6
7
8
9
</code></pre>
<p>It worked perfectly!</p>
<p>So, as you can see, we can write imperative algorithms quite straightforwardly in Funky!</p>
<a class="header" href="#mixing-procedures-with-io" id="mixing-procedures-with-io"><h2>Mixing procedures with IO</h2></a>
<p>Forget <a href="https://en.wikibooks.org/wiki/Haskell/Monad_transformers">monad transformers</a> (if you've used Haskell), mixing procedures with IO isn't such a big deal. I'll show you how to do it.</p>
<p>So, we have this code:</p>
<pre><code class="language-funky">func main : IO =
    let (
        start-with (Vars (empty 0) 0);
        for-pair (enumerate [2, 6, 1, 0, 4, 3, 5, 9, 7, 8])
            (\i \x (array . at i) := x);
        call (quicksort 0 9);
        return array
    ) \arr
    for (range 0 9) (
        \i \next
        println (string; at i arr);
        next
    );
    quit
</code></pre>
<p>But the <code>let</code> is in fact not needed. Remember, there's an overloaded version of <code>return</code> (which we are in fact using in this code) with this type:</p>
<pre><code class="language-funky">func return : (s -&gt; a) -&gt; Proc s a
</code></pre>
<p>How about we used it rather differently than we already have? What if we passed it a function of type <code>Vars -&gt; IO</code>? Something like this:</p>
<pre><code class="language-funky">func main : IO =
    start-with (Vars (empty 0) 0);
    for-pair (enumerate [2, 6, 1, 0, 4, 3, 5, 9, 7, 8])
        (\i \x (array . at i) := x);
    call (quicksort 0 9);
    return \vars                              # &lt;
    for (range 0 9) (                         # &lt;
        \i \next                              # &lt;
        println (string; at i (array vars));  # &lt;
        next                                  # &lt;
    );                                        # &lt;
    quit                                      # &lt;
</code></pre>
<p>I marked the function which we passed to <code>return</code>. It took <code>vars</code>, which is the whole state of the above procedure and made some <code>IO</code> out of it. The whole procedure now has type <code>Proc Vars IO</code> and so <code>start-with</code> turns it into just <code>IO</code>. Everything works:</p>
<pre><code>$ funkycmd quicksort.fn
0
1
2
3
4
5
6
7
8
9
</code></pre>
<p><strong>That's how we switch from <code>Proc</code> to <code>IO</code>!</strong> How do we switch back? Just <code>start-with</code> again! You have the last state, reuse it. We need to make sure, though, that we return some <code>IO</code> at the end.</p>
<p>Here's a simple program that reads 10 numbers from the input and prints out the average after each one (uses the <code>Average</code> record we defined earlier):</p>
<pre><code class="language-funky">func main : IO =
    start-with (Average 0 0);

    for (range 1 10) (
        \i \next
        call average \avg
        return \a
        println (&quot;Current average is &quot; ++ string avg ++ &quot;.&quot;);
        print (&quot;Number #&quot; ++ string i ++ &quot;: &quot;);
        scanln; int |&gt; \x
        start-with a;
        call (add x);
        next
    );

    call average \avg
    return \a
    println (&quot;Final average is &quot; ++ string avg ++ &quot;.&quot;);
    quit
</code></pre>
<p>I'm sure we could shave off some lines in a true imperative language, but so what! It's not bad for a purely functional one.</p>
<p>That's all for this part. In the next part, we'll shine some light on <em>&quot;exception&quot; handling</em>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="3-2-yield-it-all.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="3-4-maybe-some-pairs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="3-2-yield-it-all.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="3-4-maybe-some-pairs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
